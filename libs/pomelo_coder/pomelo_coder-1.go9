package coder1

import (
	"crypto/md5"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/gorilla/websocket"
	"gogo-connector/components/global"
	"strings"
)

// user conn 状态
const (
	StateInited  = 0
	StateWaitAck = 1
	StateWorking = 2
	StateClosed  = 3
)

// 握手状态
const (
	CODE_OK         = 200
	CODE_USE_ERROR  = 500
	CODE_OLD_CLIENT = 501
)

//===================== handle pomelo protocol ===========================

type PomeloCoder struct {
	State rune
}

// 处理客户端handshake
// 检查整体状态 ST_INITED
// todo checkClient
// var opts = { heartbeat : setupHeartbeat(this) };
//  opts.useProto = true;
// 返回 TYPE_HANDSHAKE 报文， 携带上述的对象 packageEncode
func (p *PomeloCoder) HandleHandshake(user *UserConn) {
	if p.State != StateInited {
		user.Cancel()
		return
	}
	s := handshake{
		Code: CODE_OK,
		Sys: sys{
			Heartbeat:   60,
			Dict:        dict{},
			RouteToCode: routeToCode{},
			CodeToRoute: codeToRoute{},
			DictVersion: genDictVersion(),
			UseDict:     true,
			UseProto:    true,
		},
	}
	j, _ := json.Marshal(s)

	p := PackageEncode(Package["TYPE_HANDSHAKE"], []byte(string(j)))
	user.MsgPush <- p
	user.State = StateWaitAck
	// fmt.Println("handshacke handler = 0")
}
func HandleHandshake(user *UserConn) {
	if user.State != StateInited {
		user.Cancel()
		return
	}
	s := handshake{
		Code: CODE_OK,
		Sys: sys{
			Heartbeat:   60,
			Dict:        dict{},
			RouteToCode: routeToCode{},
			CodeToRoute: codeToRoute{},
			DictVersion: genDictVersion(),
			UseDict:     true,
			UseProto:    true,
		},
	}
	j, _ := json.Marshal(s)
	p := PackageEncode(Package["TYPE_HANDSHAKE"], []byte(string(j)))
	user.MsgPush <- p
	user.State = StateWaitAck
	// fmt.Println("handshacke handler = 0")
}

//
func (p *PomeloCoder) HandleHandshakeAck() bool {
	if p.State != StateWaitAck {
		//user.Cancel()
		return false
	}
	p.State = StateWorking
	return true
}
func HandleHandshakeAck(user *UserConn) {
	if user.State != StateWaitAck {
		user.Cancel()
		return
	}
	user.State = StateWorking
}

func genDictVersion() string {
	m := md5.Sum([]byte("{}"))
	return base64.StdEncoding.EncodeToString(m[:])
}

func (p *PomeloCoder) HandleData(user *UserConn, b []byte) (userreq global.UserReq) {
	if user.State != StateWorking {
		user.Cancel()
		return
	}

	c := MessageDecode(b)
	fmt.Println(c.Route, string(c.Body))
	serverType := strings.SplitN(c.Route, ".", 2)[0]
	if serverType == "" {
		return
	}
	sss, ok1 := global.RemoteTypeStore.Get(serverType)
	if !ok1 {
		fmt.Println("no found server>>", serverType, c.Route)
		return
	}
	ssss, ok2 := sss.(*global.RemoteTypeStoreType)
	if !ok2 {
		fmt.Println("parse server>>", serverType)
		return
	}
	fmt.Println("serverType:", serverType, "server.len:", len(ssss.Servers), ok1, ok2)

	userreq = global.UserReq{
		UID:        user.UID,
		Route:      c.Route,
		ServerType: serverType,
		Payload:    c.Body,
		PkgID:      c.ID,
		Sid:        user.Sid,
	}

	if ssss.ForwardCh == nil {
		return
	}

	fmt.Println("将要写入消息", serverType)

	select {
	case ssss.ForwardCh <- userreq:
	default:
		{
			fmt.Println("写入失败，队列堵塞", serverType)
		}
	}

	return
}
func HandleData(user *UserConn, b []byte) (userreq global.UserReq) {
	if user.State != StateWorking {
		user.Cancel()
		return
	}

	c := MessageDecode(b)
	fmt.Println(c.Route, string(c.Body))
	serverType := strings.SplitN(c.Route, ".", 2)[0]
	if serverType == "" {
		return
	}
	sss, ok1 := global.RemoteTypeStore.Get(serverType)
	if !ok1 {
		fmt.Println("no found server>>", serverType, c.Route)
		return
	}
	ssss, ok2 := sss.(*global.RemoteTypeStoreType)
	if !ok2 {
		fmt.Println("parse server>>", serverType)
		return
	}
	fmt.Println("serverType:", serverType, "server.len:", len(ssss.Servers), ok1, ok2)

	userreq = global.UserReq{
		UID:        user.UID,
		Route:      c.Route,
		ServerType: serverType,
		Payload:    c.Body,
		PkgID:      c.ID,
		Sid:        user.Sid,
	}

	if ssss.ForwardCh == nil {
		return
	}

	fmt.Println("将要写入消息", serverType)

	select {
	case ssss.ForwardCh <- userreq:
	default:
		{
			fmt.Println("写入失败，队列堵塞", serverType)
		}
	}

	return
}

type KickMsg struct {
	Reason string `json:"reason"`
}

var defaultKick = []byte(`{"reson":"kick"}`)

func (p *PomeloCoder) handleKick(code int32, msg string, conn *websocket.Conn) {
	r, err := json.Marshal(KickMsg{Reason: msg})
	if err != nil {
		r = defaultKick
	}
	b := PackageEncode(Package["TYPE_KICK"], r)
	if err := conn.WriteMessage(websocket.BinaryMessage, b); err != nil {
		fmt.Println(err)
		return
	}
}

func handleKick(code int32, msg string, conn *websocket.Conn) {
	r, err := json.Marshal(KickMsg{Reason: msg})
	if err != nil {
		r = defaultKick
	}
	b := PackageEncode(Package["TYPE_KICK"], r)
	if err := conn.WriteMessage(websocket.BinaryMessage, b); err != nil {
		fmt.Println(err)
		return
	}
}
